// Code generated by MockGen. DO NOT EDIT.
// Source: ResuMatch/internal/repository (interfaces: VacancyRepository)
//
// Generated by this command:
//
//	mockgen -package mock -destination internal/repository/mock/mock_vacancy.go ResuMatch/internal/repository VacancyRepository
//

// Package mock is a generated GoMock package.
package mock

import (
	entity "ResuMatch/internal/entity"
	context "context"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockVacancyRepository is a mock of VacancyRepository interface.
type MockVacancyRepository struct {
	ctrl     *gomock.Controller
	recorder *MockVacancyRepositoryMockRecorder
	isgomock struct{}
}

// MockVacancyRepositoryMockRecorder is the mock recorder for MockVacancyRepository.
type MockVacancyRepositoryMockRecorder struct {
	mock *MockVacancyRepository
}

// NewMockVacancyRepository creates a new mock instance.
func NewMockVacancyRepository(ctrl *gomock.Controller) *MockVacancyRepository {
	mock := &MockVacancyRepository{ctrl: ctrl}
	mock.recorder = &MockVacancyRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockVacancyRepository) EXPECT() *MockVacancyRepositoryMockRecorder {
	return m.recorder
}

// AddCity mocks base method.
func (m *MockVacancyRepository) AddCity(ctx context.Context, vacancyID int, cityIDs []int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddCity", ctx, vacancyID, cityIDs)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddCity indicates an expected call of AddCity.
func (mr *MockVacancyRepositoryMockRecorder) AddCity(ctx, vacancyID, cityIDs any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddCity", reflect.TypeOf((*MockVacancyRepository)(nil).AddCity), ctx, vacancyID, cityIDs)
}

// AddSkills mocks base method.
func (m *MockVacancyRepository) AddSkills(ctx context.Context, vacancyID int, skillIDs []int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddSkills", ctx, vacancyID, skillIDs)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddSkills indicates an expected call of AddSkills.
func (mr *MockVacancyRepositoryMockRecorder) AddSkills(ctx, vacancyID, skillIDs any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddSkills", reflect.TypeOf((*MockVacancyRepository)(nil).AddSkills), ctx, vacancyID, skillIDs)
}

// Create mocks base method.
func (m *MockVacancyRepository) Create(ctx context.Context, vacancy *entity.Vacancy) (*entity.Vacancy, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, vacancy)
	ret0, _ := ret[0].(*entity.Vacancy)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Create indicates an expected call of Create.
func (mr *MockVacancyRepositoryMockRecorder) Create(ctx, vacancy any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockVacancyRepository)(nil).Create), ctx, vacancy)
}

// CreateLike mocks base method.
func (m *MockVacancyRepository) CreateLike(ctx context.Context, vacancyID, applicantID int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateLike", ctx, vacancyID, applicantID)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateLike indicates an expected call of CreateLike.
func (mr *MockVacancyRepositoryMockRecorder) CreateLike(ctx, vacancyID, applicantID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateLike", reflect.TypeOf((*MockVacancyRepository)(nil).CreateLike), ctx, vacancyID, applicantID)
}

// CreateResponse mocks base method.
func (m *MockVacancyRepository) CreateResponse(ctx context.Context, vacancyID, applicantID, resumeID int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateResponse", ctx, vacancyID, applicantID, resumeID)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateResponse indicates an expected call of CreateResponse.
func (mr *MockVacancyRepositoryMockRecorder) CreateResponse(ctx, vacancyID, applicantID, resumeID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateResponse", reflect.TypeOf((*MockVacancyRepository)(nil).CreateResponse), ctx, vacancyID, applicantID, resumeID)
}

// CreateSkillIfNotExists mocks base method.
func (m *MockVacancyRepository) CreateSkillIfNotExists(ctx context.Context, skillName string) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateSkillIfNotExists", ctx, skillName)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateSkillIfNotExists indicates an expected call of CreateSkillIfNotExists.
func (mr *MockVacancyRepositoryMockRecorder) CreateSkillIfNotExists(ctx, skillName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateSkillIfNotExists", reflect.TypeOf((*MockVacancyRepository)(nil).CreateSkillIfNotExists), ctx, skillName)
}

// CreateSpecializationIfNotExists mocks base method.
func (m *MockVacancyRepository) CreateSpecializationIfNotExists(ctx context.Context, specializationName string) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateSpecializationIfNotExists", ctx, specializationName)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateSpecializationIfNotExists indicates an expected call of CreateSpecializationIfNotExists.
func (mr *MockVacancyRepositoryMockRecorder) CreateSpecializationIfNotExists(ctx, specializationName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateSpecializationIfNotExists", reflect.TypeOf((*MockVacancyRepository)(nil).CreateSpecializationIfNotExists), ctx, specializationName)
}

// Delete mocks base method.
func (m *MockVacancyRepository) Delete(ctx context.Context, vacancyID int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, vacancyID)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockVacancyRepositoryMockRecorder) Delete(ctx, vacancyID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockVacancyRepository)(nil).Delete), ctx, vacancyID)
}

// DeleteCity mocks base method.
func (m *MockVacancyRepository) DeleteCity(ctx context.Context, vacancyID int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteCity", ctx, vacancyID)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteCity indicates an expected call of DeleteCity.
func (mr *MockVacancyRepositoryMockRecorder) DeleteCity(ctx, vacancyID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteCity", reflect.TypeOf((*MockVacancyRepository)(nil).DeleteCity), ctx, vacancyID)
}

// DeleteLike mocks base method.
func (m *MockVacancyRepository) DeleteLike(ctx context.Context, vacancyID, applicantID int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteLike", ctx, vacancyID, applicantID)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteLike indicates an expected call of DeleteLike.
func (mr *MockVacancyRepositoryMockRecorder) DeleteLike(ctx, vacancyID, applicantID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteLike", reflect.TypeOf((*MockVacancyRepository)(nil).DeleteLike), ctx, vacancyID, applicantID)
}

// DeleteResponse mocks base method.
func (m *MockVacancyRepository) DeleteResponse(ctx context.Context, vacancyID, applicantID, resumeID int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteResponse", ctx, vacancyID, applicantID, resumeID)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteResponse indicates an expected call of DeleteResponse.
func (mr *MockVacancyRepositoryMockRecorder) DeleteResponse(ctx, vacancyID, applicantID, resumeID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteResponse", reflect.TypeOf((*MockVacancyRepository)(nil).DeleteResponse), ctx, vacancyID, applicantID, resumeID)
}

// DeleteSkills mocks base method.
func (m *MockVacancyRepository) DeleteSkills(ctx context.Context, vacancyID int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteSkills", ctx, vacancyID)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteSkills indicates an expected call of DeleteSkills.
func (mr *MockVacancyRepositoryMockRecorder) DeleteSkills(ctx, vacancyID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSkills", reflect.TypeOf((*MockVacancyRepository)(nil).DeleteSkills), ctx, vacancyID)
}

// FindCityIDsByNames mocks base method.
func (m *MockVacancyRepository) FindCityIDsByNames(ctx context.Context, cityNames []string) ([]int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindCityIDsByNames", ctx, cityNames)
	ret0, _ := ret[0].([]int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindCityIDsByNames indicates an expected call of FindCityIDsByNames.
func (mr *MockVacancyRepositoryMockRecorder) FindCityIDsByNames(ctx, cityNames any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindCityIDsByNames", reflect.TypeOf((*MockVacancyRepository)(nil).FindCityIDsByNames), ctx, cityNames)
}

// FindSkillIDsByNames mocks base method.
func (m *MockVacancyRepository) FindSkillIDsByNames(ctx context.Context, skillNames []string) ([]int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindSkillIDsByNames", ctx, skillNames)
	ret0, _ := ret[0].([]int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindSkillIDsByNames indicates an expected call of FindSkillIDsByNames.
func (mr *MockVacancyRepositoryMockRecorder) FindSkillIDsByNames(ctx, skillNames any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindSkillIDsByNames", reflect.TypeOf((*MockVacancyRepository)(nil).FindSkillIDsByNames), ctx, skillNames)
}

// FindSpecializationIDByName mocks base method.
func (m *MockVacancyRepository) FindSpecializationIDByName(ctx context.Context, specializationName string) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindSpecializationIDByName", ctx, specializationName)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindSpecializationIDByName indicates an expected call of FindSpecializationIDByName.
func (mr *MockVacancyRepositoryMockRecorder) FindSpecializationIDByName(ctx, specializationName any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindSpecializationIDByName", reflect.TypeOf((*MockVacancyRepository)(nil).FindSpecializationIDByName), ctx, specializationName)
}

// FindSpecializationIDsByNames mocks base method.
func (m *MockVacancyRepository) FindSpecializationIDsByNames(ctx context.Context, specializationNames []string) ([]int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindSpecializationIDsByNames", ctx, specializationNames)
	ret0, _ := ret[0].([]int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindSpecializationIDsByNames indicates an expected call of FindSpecializationIDsByNames.
func (mr *MockVacancyRepositoryMockRecorder) FindSpecializationIDsByNames(ctx, specializationNames any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindSpecializationIDsByNames", reflect.TypeOf((*MockVacancyRepository)(nil).FindSpecializationIDsByNames), ctx, specializationNames)
}

// GetActiveVacanciesByEmployerID mocks base method.
func (m *MockVacancyRepository) GetActiveVacanciesByEmployerID(ctx context.Context, employerID, limit, offset int) ([]*entity.Vacancy, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetActiveVacanciesByEmployerID", ctx, employerID, limit, offset)
	ret0, _ := ret[0].([]*entity.Vacancy)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetActiveVacanciesByEmployerID indicates an expected call of GetActiveVacanciesByEmployerID.
func (mr *MockVacancyRepositoryMockRecorder) GetActiveVacanciesByEmployerID(ctx, employerID, limit, offset any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetActiveVacanciesByEmployerID", reflect.TypeOf((*MockVacancyRepository)(nil).GetActiveVacanciesByEmployerID), ctx, employerID, limit, offset)
}

// GetAll mocks base method.
func (m *MockVacancyRepository) GetAll(ctx context.Context, limit, offset int) ([]*entity.Vacancy, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAll", ctx, limit, offset)
	ret0, _ := ret[0].([]*entity.Vacancy)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAll indicates an expected call of GetAll.
func (mr *MockVacancyRepositoryMockRecorder) GetAll(ctx, limit, offset any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAll", reflect.TypeOf((*MockVacancyRepository)(nil).GetAll), ctx, limit, offset)
}

// GetByID mocks base method.
func (m *MockVacancyRepository) GetByID(ctx context.Context, id int) (*entity.Vacancy, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByID", ctx, id)
	ret0, _ := ret[0].(*entity.Vacancy)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByID indicates an expected call of GetByID.
func (mr *MockVacancyRepositoryMockRecorder) GetByID(ctx, id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockVacancyRepository)(nil).GetByID), ctx, id)
}

// GetCityByVacancyID mocks base method.
func (m *MockVacancyRepository) GetCityByVacancyID(ctx context.Context, vacancyID int) ([]entity.City, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCityByVacancyID", ctx, vacancyID)
	ret0, _ := ret[0].([]entity.City)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCityByVacancyID indicates an expected call of GetCityByVacancyID.
func (mr *MockVacancyRepositoryMockRecorder) GetCityByVacancyID(ctx, vacancyID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCityByVacancyID", reflect.TypeOf((*MockVacancyRepository)(nil).GetCityByVacancyID), ctx, vacancyID)
}

// GetSkillsByVacancyID mocks base method.
func (m *MockVacancyRepository) GetSkillsByVacancyID(ctx context.Context, vacancyID int) ([]entity.Skill, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSkillsByVacancyID", ctx, vacancyID)
	ret0, _ := ret[0].([]entity.Skill)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSkillsByVacancyID indicates an expected call of GetSkillsByVacancyID.
func (mr *MockVacancyRepositoryMockRecorder) GetSkillsByVacancyID(ctx, vacancyID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSkillsByVacancyID", reflect.TypeOf((*MockVacancyRepository)(nil).GetSkillsByVacancyID), ctx, vacancyID)
}

// GetVacanciesByApplicantID mocks base method.
func (m *MockVacancyRepository) GetVacanciesByApplicantID(ctx context.Context, applicantID, limit, offset int) ([]*entity.Vacancy, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetVacanciesByApplicantID", ctx, applicantID, limit, offset)
	ret0, _ := ret[0].([]*entity.Vacancy)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetVacanciesByApplicantID indicates an expected call of GetVacanciesByApplicantID.
func (mr *MockVacancyRepositoryMockRecorder) GetVacanciesByApplicantID(ctx, applicantID, limit, offset any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVacanciesByApplicantID", reflect.TypeOf((*MockVacancyRepository)(nil).GetVacanciesByApplicantID), ctx, applicantID, limit, offset)
}

// GetVacancyResponses mocks base method.
func (m *MockVacancyRepository) GetVacancyResponses(ctx context.Context, vacancyID, limit, offset int) ([]*entity.VacancyResponses, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetVacancyResponses", ctx, vacancyID, limit, offset)
	ret0, _ := ret[0].([]*entity.VacancyResponses)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetVacancyResponses indicates an expected call of GetVacancyResponses.
func (mr *MockVacancyRepositoryMockRecorder) GetVacancyResponses(ctx, vacancyID, limit, offset any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVacancyResponses", reflect.TypeOf((*MockVacancyRepository)(nil).GetVacancyResponses), ctx, vacancyID, limit, offset)
}

// GetlikedVacancies mocks base method.
func (m *MockVacancyRepository) GetlikedVacancies(ctx context.Context, applicantID, limit, offset int) ([]*entity.Vacancy, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetlikedVacancies", ctx, applicantID, limit, offset)
	ret0, _ := ret[0].([]*entity.Vacancy)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetlikedVacancies indicates an expected call of GetlikedVacancies.
func (mr *MockVacancyRepositoryMockRecorder) GetlikedVacancies(ctx, applicantID, limit, offset any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetlikedVacancies", reflect.TypeOf((*MockVacancyRepository)(nil).GetlikedVacancies), ctx, applicantID, limit, offset)
}

// LikeExists mocks base method.
func (m *MockVacancyRepository) LikeExists(ctx context.Context, vacancyID, applicantID int) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LikeExists", ctx, vacancyID, applicantID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LikeExists indicates an expected call of LikeExists.
func (mr *MockVacancyRepositoryMockRecorder) LikeExists(ctx, vacancyID, applicantID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LikeExists", reflect.TypeOf((*MockVacancyRepository)(nil).LikeExists), ctx, vacancyID, applicantID)
}

// ResponseExists mocks base method.
func (m *MockVacancyRepository) ResponseExists(ctx context.Context, vacancyID, applicantID int) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResponseExists", ctx, vacancyID, applicantID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ResponseExists indicates an expected call of ResponseExists.
func (mr *MockVacancyRepositoryMockRecorder) ResponseExists(ctx, vacancyID, applicantID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResponseExists", reflect.TypeOf((*MockVacancyRepository)(nil).ResponseExists), ctx, vacancyID, applicantID)
}

// ResponseExistsForApplicant mocks base method.
func (m *MockVacancyRepository) ResponseExistsForApplicant(ctx context.Context, vacancyID, applicantID, resumeID int) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResponseExistsForApplicant", ctx, vacancyID, applicantID, resumeID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ResponseExistsForApplicant indicates an expected call of ResponseExistsForApplicant.
func (mr *MockVacancyRepositoryMockRecorder) ResponseExistsForApplicant(ctx, vacancyID, applicantID, resumeID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResponseExistsForApplicant", reflect.TypeOf((*MockVacancyRepository)(nil).ResponseExistsForApplicant), ctx, vacancyID, applicantID, resumeID)
}

// SearchVacancies mocks base method.
func (m *MockVacancyRepository) SearchVacancies(ctx context.Context, searchQuery string, limit, offset int) ([]*entity.Vacancy, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SearchVacancies", ctx, searchQuery, limit, offset)
	ret0, _ := ret[0].([]*entity.Vacancy)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SearchVacancies indicates an expected call of SearchVacancies.
func (mr *MockVacancyRepositoryMockRecorder) SearchVacancies(ctx, searchQuery, limit, offset any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchVacancies", reflect.TypeOf((*MockVacancyRepository)(nil).SearchVacancies), ctx, searchQuery, limit, offset)
}

// SearchVacanciesByEmployerID mocks base method.
func (m *MockVacancyRepository) SearchVacanciesByEmployerID(ctx context.Context, employerID int, searchQuery string, limit, offset int) ([]*entity.Vacancy, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SearchVacanciesByEmployerID", ctx, employerID, searchQuery, limit, offset)
	ret0, _ := ret[0].([]*entity.Vacancy)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SearchVacanciesByEmployerID indicates an expected call of SearchVacanciesByEmployerID.
func (mr *MockVacancyRepositoryMockRecorder) SearchVacanciesByEmployerID(ctx, employerID, searchQuery, limit, offset any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchVacanciesByEmployerID", reflect.TypeOf((*MockVacancyRepository)(nil).SearchVacanciesByEmployerID), ctx, employerID, searchQuery, limit, offset)
}

// SearchVacanciesByQueryAndSpecializations mocks base method.
func (m *MockVacancyRepository) SearchVacanciesByQueryAndSpecializations(ctx context.Context, searchQuery string, specializationIDs []int, minSalary int, employment, experience []string, limit, offset int) ([]*entity.Vacancy, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SearchVacanciesByQueryAndSpecializations", ctx, searchQuery, specializationIDs, minSalary, employment, experience, limit, offset)
	ret0, _ := ret[0].([]*entity.Vacancy)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SearchVacanciesByQueryAndSpecializations indicates an expected call of SearchVacanciesByQueryAndSpecializations.
func (mr *MockVacancyRepositoryMockRecorder) SearchVacanciesByQueryAndSpecializations(ctx, searchQuery, specializationIDs, minSalary, employment, experience, limit, offset any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchVacanciesByQueryAndSpecializations", reflect.TypeOf((*MockVacancyRepository)(nil).SearchVacanciesByQueryAndSpecializations), ctx, searchQuery, specializationIDs, minSalary, employment, experience, limit, offset)
}

// SearchVacanciesBySpecializations mocks base method.
func (m *MockVacancyRepository) SearchVacanciesBySpecializations(ctx context.Context, specializationIDs []int, limit, offset int) ([]*entity.Vacancy, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SearchVacanciesBySpecializations", ctx, specializationIDs, limit, offset)
	ret0, _ := ret[0].([]*entity.Vacancy)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SearchVacanciesBySpecializations indicates an expected call of SearchVacanciesBySpecializations.
func (mr *MockVacancyRepositoryMockRecorder) SearchVacanciesBySpecializations(ctx, specializationIDs, limit, offset any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchVacanciesBySpecializations", reflect.TypeOf((*MockVacancyRepository)(nil).SearchVacanciesBySpecializations), ctx, specializationIDs, limit, offset)
}

// Update mocks base method.
func (m *MockVacancyRepository) Update(ctx context.Context, vacancy *entity.Vacancy) (*entity.Vacancy, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, vacancy)
	ret0, _ := ret[0].(*entity.Vacancy)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockVacancyRepositoryMockRecorder) Update(ctx, vacancy any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockVacancyRepository)(nil).Update), ctx, vacancy)
}
